/* tslint:disable */
/* eslint-disable */
/**
 * Fitbit Web API Explorer
 * Fitbit provides a Web API for accessing data from Fitbit activity trackers, Aria scale, and manually entered logs. Anyone can develop an application to access and modify a Fitbit user\'s data on their behalf, so long as it complies with Fitbit Platform Terms of Service. These Swagger UI docs do not currently support making Fitbit API requests directly. In order to make a request, construct a request for the appropriate endpoint using this documentation, and then add an Authorization header to each request with an access token obtained using the steps outlined here: https://dev.fitbit.com/build/reference/web-api/developer-guide/authorization/.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";

export interface GetHeartByDateIntradayRequest {
  date: Date;
  detailLevel: string;
}

export interface GetHeartByDateRangeIntradayRequest {
  date: Date;
  endDate: Date;
  detailLevel: string;
}

export interface GetHeartByDateRangeTimestampIntradayRequest {
  date: Date;
  endDate: Date;
  detailLevel: string;
  startTime: string;
  endTime: string;
}

export interface GetHeartByDateTimestampIntradayRequest {
  date: Date;
  detailLevel: string;
  startTime: string;
  endTime: string;
}

/**
 *
 */
export class HeartRateIntradayTimeSeriesApi extends runtime.BaseAPI {
  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateIntradayRaw(
    requestParameters: GetHeartByDateIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.date === null ||
      requestParameters.date === undefined
    ) {
      throw new runtime.RequiredError(
        "date",
        "Required parameter requestParameters.date was null or undefined when calling getHeartByDateIntraday.",
      );
    }

    if (
      requestParameters.detailLevel === null ||
      requestParameters.detailLevel === undefined
    ) {
      throw new runtime.RequiredError(
        "detailLevel",
        "Required parameter requestParameters.detailLevel was null or undefined when calling getHeartByDateIntraday.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth2",
        [
          "activity",
          "heartrate",
          "location",
          "nutrition",
          "profile",
          "settings",
          "sleep",
          "social",
          "weight",
        ],
      );
    }

    const response = await this.request(
      {
        path: `/1/user/-/activities/heart/date/{date}/1d/{detail-level}.json`
          .replace(
            `{${"date"}}`,
            encodeURIComponent(String(requestParameters.date)),
          )
          .replace(
            `{${"detail-level"}}`,
            encodeURIComponent(String(requestParameters.detailLevel)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateIntraday(
    requestParameters: GetHeartByDateIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.getHeartByDateIntradayRaw(requestParameters, initOverrides);
  }

  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateRangeIntradayRaw(
    requestParameters: GetHeartByDateRangeIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.date === null ||
      requestParameters.date === undefined
    ) {
      throw new runtime.RequiredError(
        "date",
        "Required parameter requestParameters.date was null or undefined when calling getHeartByDateRangeIntraday.",
      );
    }

    if (
      requestParameters.endDate === null ||
      requestParameters.endDate === undefined
    ) {
      throw new runtime.RequiredError(
        "endDate",
        "Required parameter requestParameters.endDate was null or undefined when calling getHeartByDateRangeIntraday.",
      );
    }

    if (
      requestParameters.detailLevel === null ||
      requestParameters.detailLevel === undefined
    ) {
      throw new runtime.RequiredError(
        "detailLevel",
        "Required parameter requestParameters.detailLevel was null or undefined when calling getHeartByDateRangeIntraday.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth2",
        [
          "activity",
          "heartrate",
          "location",
          "nutrition",
          "profile",
          "settings",
          "sleep",
          "social",
          "weight",
        ],
      );
    }

    const response = await this.request(
      {
        path: `/1/user/-/activities/heart/date/{date}/{end-date}/{detail-level}.json`
          .replace(
            `{${"date"}}`,
            encodeURIComponent(String(requestParameters.date)),
          )
          .replace(
            `{${"end-date"}}`,
            encodeURIComponent(String(requestParameters.endDate)),
          )
          .replace(
            `{${"detail-level"}}`,
            encodeURIComponent(String(requestParameters.detailLevel)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateRangeIntraday(
    requestParameters: GetHeartByDateRangeIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.getHeartByDateRangeIntradayRaw(requestParameters, initOverrides);
  }

  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateRangeTimestampIntradayRaw(
    requestParameters: GetHeartByDateRangeTimestampIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.date === null ||
      requestParameters.date === undefined
    ) {
      throw new runtime.RequiredError(
        "date",
        "Required parameter requestParameters.date was null or undefined when calling getHeartByDateRangeTimestampIntraday.",
      );
    }

    if (
      requestParameters.endDate === null ||
      requestParameters.endDate === undefined
    ) {
      throw new runtime.RequiredError(
        "endDate",
        "Required parameter requestParameters.endDate was null or undefined when calling getHeartByDateRangeTimestampIntraday.",
      );
    }

    if (
      requestParameters.detailLevel === null ||
      requestParameters.detailLevel === undefined
    ) {
      throw new runtime.RequiredError(
        "detailLevel",
        "Required parameter requestParameters.detailLevel was null or undefined when calling getHeartByDateRangeTimestampIntraday.",
      );
    }

    if (
      requestParameters.startTime === null ||
      requestParameters.startTime === undefined
    ) {
      throw new runtime.RequiredError(
        "startTime",
        "Required parameter requestParameters.startTime was null or undefined when calling getHeartByDateRangeTimestampIntraday.",
      );
    }

    if (
      requestParameters.endTime === null ||
      requestParameters.endTime === undefined
    ) {
      throw new runtime.RequiredError(
        "endTime",
        "Required parameter requestParameters.endTime was null or undefined when calling getHeartByDateRangeTimestampIntraday.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth2",
        [
          "activity",
          "heartrate",
          "location",
          "nutrition",
          "profile",
          "settings",
          "sleep",
          "social",
          "weight",
        ],
      );
    }

    const response = await this.request(
      {
        path: `/1/user/-/activities/heart/date/{date}/{end-date}/{detail-level}/time/{start-time}/{end-time}.json`
          .replace(
            `{${"date"}}`,
            encodeURIComponent(String(requestParameters.date)),
          )
          .replace(
            `{${"end-date"}}`,
            encodeURIComponent(String(requestParameters.endDate)),
          )
          .replace(
            `{${"detail-level"}}`,
            encodeURIComponent(String(requestParameters.detailLevel)),
          )
          .replace(
            `{${"start-time"}}`,
            encodeURIComponent(String(requestParameters.startTime)),
          )
          .replace(
            `{${"end-time"}}`,
            encodeURIComponent(String(requestParameters.endTime)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateRangeTimestampIntraday(
    requestParameters: GetHeartByDateRangeTimestampIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.getHeartByDateRangeTimestampIntradayRaw(
      requestParameters,
      initOverrides,
    );
  }

  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateTimestampIntradayRaw(
    requestParameters: GetHeartByDateTimestampIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.date === null ||
      requestParameters.date === undefined
    ) {
      throw new runtime.RequiredError(
        "date",
        "Required parameter requestParameters.date was null or undefined when calling getHeartByDateTimestampIntraday.",
      );
    }

    if (
      requestParameters.detailLevel === null ||
      requestParameters.detailLevel === undefined
    ) {
      throw new runtime.RequiredError(
        "detailLevel",
        "Required parameter requestParameters.detailLevel was null or undefined when calling getHeartByDateTimestampIntraday.",
      );
    }

    if (
      requestParameters.startTime === null ||
      requestParameters.startTime === undefined
    ) {
      throw new runtime.RequiredError(
        "startTime",
        "Required parameter requestParameters.startTime was null or undefined when calling getHeartByDateTimestampIntraday.",
      );
    }

    if (
      requestParameters.endTime === null ||
      requestParameters.endTime === undefined
    ) {
      throw new runtime.RequiredError(
        "endTime",
        "Required parameter requestParameters.endTime was null or undefined when calling getHeartByDateTimestampIntraday.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth2",
        [
          "activity",
          "heartrate",
          "location",
          "nutrition",
          "profile",
          "settings",
          "sleep",
          "social",
          "weight",
        ],
      );
    }

    const response = await this.request(
      {
        path: `/1/user/-/activities/heart/date/{date}/1d/{detail-level}/time/{start-time}/{end-time}.json`
          .replace(
            `{${"date"}}`,
            encodeURIComponent(String(requestParameters.date)),
          )
          .replace(
            `{${"detail-level"}}`,
            encodeURIComponent(String(requestParameters.detailLevel)),
          )
          .replace(
            `{${"start-time"}}`,
            encodeURIComponent(String(requestParameters.startTime)),
          )
          .replace(
            `{${"end-time"}}`,
            encodeURIComponent(String(requestParameters.endTime)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
   * Get Heart Rate Intraday Time Series
   */
  async getHeartByDateTimestampIntraday(
    requestParameters: GetHeartByDateTimestampIntradayRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.getHeartByDateTimestampIntradayRaw(
      requestParameters,
      initOverrides,
    );
  }
}
